    def execute(self, context: bpy.types.Context):

        context.active_object.select_set(True)
        bpy.ops.uma.refine_bone_structure()

        mmr = context.object.mmr
       
        mod = next((m for m in addon_utils.modules() if m.__name__ == "MikuMikuRig"), None)
        if mod is None:
            self.report({'ERROR'},"MMR not found")
            return {'CANCELLED'}

        # 将当前文件夹路径和文件名组合成完整的文件路径
        mmr_path = os.path.dirname(mod.__file__)
        blend_file_path = os.path.join(mmr_path, "addons", "MikuMikuRig", "operators", "MMR_Rig.blend")

        # 设置追加参数
        filepath = os.path.join(blend_file_path, "Object", "MMR_Rig_relative")
        directory = os.path.join(blend_file_path, "Object")
        filename = "MMR_Rig_relative"

        # 执行追加操作
        if bpy.data.objects.get('MMR_Rig_relative') is None:
            bpy.ops.wm.append(
                filepath=filepath,
                directory=directory,
                filename=filename,
            )

        # 检测是否开启rigify
        if 'rigify' not in bpy.context.preferences.addons.keys():
            logging.info("检测到未开启rigify，已自动开启")
            bpy.ops.preferences.addon_enable(module="rigify")

        # 切换物体模式
        bpy.ops.object.mode_set(mode='OBJECT')
        # 当前活动物体名称
        mmd_arm = bpy.context.active_object
        print("当前活动骨骼名称:", mmd_arm.name)

        # 记住变换
        mmd_arm_matrix = mmd_arm.matrix_world.copy()

        # 清除旋转
        mmd_arm.rotation_euler = (0, 0, 0)

        # 激活物体
        bpy.context.view_layer.objects.active = mmd_arm
        mmd_arm.select_set(True)

        # 应用旋转变换
        bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)

        RIG = bpy.data.objects.get("MMR_Rig_relative")

        def check_keywords(target_string: str, keywords) -> bool:
            """
            检查目标字符串是否包含指定关键词列表中的任意一个
            :param target_string: 待检查的目标字符串
            :return: 若包含任意关键词返回True，否则返回False
            """
            for keyword in keywords:
                if keyword in target_string:
                    return True
            return False

        # 判断字符串的左(L)右(R)
        def determine_side(s):
            parts = s.split('.')
            if len(parts) < 1:
                return None
            suffix = parts[-1].strip().upper()  # 统一转大写并去除首尾空格
            if suffix == 'L':
                return True
            elif suffix == 'R':
                return False
            else:
                return None

        def get_bone_world_rotation(armature_obj, bone_name):
            # 获取骨骼对象
            bone = armature_obj.pose.bones.get(bone_name)
            if bone is None:
                print(f"骨骼 {bone_name} 未找到。")
                return None

            # 获取骨骼的矩阵
            bone_matrix = armature_obj.matrix_world @ bone.matrix

            # 获取旋转部分(四元数)
            rotation = bone_matrix.to_quaternion()

            # 将四元数转换为欧拉角(弧度)
            euler_rotation = rotation.to_euler()

            return euler_rotation

        # 对齐骨骼roll
        def align_bones_roll(A, D, B, C):
            # A骨骼(D骨架),B骨骼(C骨架)
            # 获取 D 骨架和 C 骨架对象
            D_armature_obj = bpy.data.objects.get(D)
            C_armature_obj = bpy.data.objects.get(C)

            if not D_armature_obj or not C_armature_obj:
                print("未找到 D 骨架或 C 骨架对象，请检查名称。")
                return

            if D_armature_obj.type != 'ARMATURE' or C_armature_obj.type != 'ARMATURE':
                print("D 或 C 对象不是骨架类型，请检查。")
                return

            # 进入 D 骨架的编辑模式
            bpy.context.view_layer.objects.active = D_armature_obj
            bpy.ops.object.mode_set(mode='EDIT')
            D_edit_bones = D_armature_obj.data.edit_bones

            # 进入 C 骨架的编辑模式
            bpy.context.view_layer.objects.active = C_armature_obj
            bpy.ops.object.mode_set(mode='EDIT')
            C_edit_bones = C_armature_obj.data.edit_bones

            # 获取 A 骨骼和 B 骨骼
            A_bone = D_edit_bones.get(A)
            B_bone = C_edit_bones.get(B)

            if not A_bone or not B_bone:
                print(f"未找到 {A} 骨骼或 {B} 骨骼，请检查名称。")
                bpy.ops.object.mode_set(mode='OBJECT')
                return

            B_bone.roll = A_bone.roll

        # 对齐骨骼
        def align_bones(A, D_armature_obj, B, C_armature_obj, Compare_Boolean=False, count = False, length = 0.0):
            # A骨骼(D骨架),B骨骼(C骨架)

            if not D_armature_obj or not C_armature_obj:
                print("未找到 D 骨架或 C 骨架对象，请检查名称。")
                return

            if D_armature_obj.type != 'ARMATURE' or C_armature_obj.type != 'ARMATURE':
                print("D 或 C 对象不是骨架类型，请检查。")
                return

            # 进入 D 骨架的编辑模式
            bpy.context.view_layer.objects.active = D_armature_obj
            bpy.ops.object.mode_set(mode='EDIT')
            D_edit_bones = D_armature_obj.data.edit_bones

            # 进入 C 骨架的编辑模式
            bpy.context.view_layer.objects.active = C_armature_obj
            bpy.ops.object.mode_set(mode='EDIT')
            C_edit_bones = C_armature_obj.data.edit_bones

            # 获取 A 骨骼和 B 骨骼
            A_bone = D_edit_bones.get(A)
            B_bone = C_edit_bones.get(B)

            if not A_bone or not B_bone:
                print(f"未找到 {A} 骨骼或 {B} 骨骼，请检查名称。")
                bpy.ops.object.mode_set(mode='OBJECT')
                return False
            else:
                if count:
                    return True

            # 转换 B 骨骼的头和尾坐标到世界空间
            world_matrix_C = C_armature_obj.matrix_world
            world_head_B = world_matrix_C @ B_bone.head
            world_tail_B = world_matrix_C @ B_bone.tail

            # 转换世界空间坐标到 D 骨架的局部空间
            world_matrix_D = D_armature_obj.matrix_world
            local_matrix_D = world_matrix_D.inverted()
            local_head_B = local_matrix_D @ world_head_B
            local_tail_B = local_matrix_D @ world_tail_B

            if Compare_Boolean:
                if local_head_B[2] < local_tail_B[2]:
                    return False
                else:
                    return True

            # 设置 A 骨骼的头和尾
            if A == 'spine':
                if local_head_B[2] < local_tail_B[2]:
                    A_bone.head = local_head_B
                    A_bone.tail = local_tail_B
                else:
                    A_bone.head = local_tail_B
                    A_bone.tail = local_head_B
            else:
                A_bone.head = local_head_B
                A_bone.tail = local_tail_B

            if length != 0.0:
                A_bone.length = A_bone.length * length

            # 退出编辑模式
            bpy.ops.object.mode_set(mode='OBJECT')

        def move_bone_a_to_b(d_armature_name, c_armature_name, bone_a_name, bone_b_name, A_bone_Z_location = False):

            # 获取 D 骨架和 C 骨架对象
            d_armature_obj = bpy.data.objects.get(d_armature_name)
            c_armature_obj = bpy.data.objects.get(c_armature_name)

            if d_armature_obj and c_armature_obj:
                # 确保 D 骨架和 C 骨架处于姿态模式
                for obj in [d_armature_obj, c_armature_obj]:
                    bpy.context.view_layer.objects.active = obj
                    bpy.ops.object.mode_set(mode='POSE')

                # 获取 A 骨骼和 B 骨骼
                bone_A = d_armature_obj.pose.bones.get(bone_a_name)
                bone_B = c_armature_obj.pose.bones.get(bone_b_name)

                if bone_A and bone_B:
                    # 下面的注释是Ai写的,不能全信
                    # 使用矩阵操作（如需同时处理位置和旋转）
                    # 1. 计算骨骼 B 的世界矩阵（包含位置、旋转、缩放）
                    world_matrix_b = c_armature_obj.matrix_world @ bone_B.matrix  # 补充此处定义

                    # 2. 分解骨骼 A 的原有旋转、Z位置和缩放（避免被覆盖）
                    original_rot = bone_A.rotation_quaternion.copy()
                    original_scale = bone_A.scale.copy()
                    A_bone_Z = bone_A.location.z

                    # 3. 设置骨骼 A 的局部矩阵（世界矩阵反转为局部空间）
                    bone_A.matrix = d_armature_obj.matrix_world.inverted() @ world_matrix_b

                    # 4. 恢复骨骼 A 的原有旋转和缩放（仅保留目标位置）
                    bone_A.rotation_quaternion = original_rot
                    bone_A.scale = original_scale

                    if A_bone_Z_location:
                        bone_A.location.z = A_bone_Z

                    # 更新场景以反映更改
                    bpy.context.view_layer.update()
                else:
                    print("未找到指定的骨骼。")
            else:
                print("未找到指定的骨架对象。")

        def Size_settings(A, B):
            obj_a = A
            obj_b = B

            if obj_a and obj_b:
                # 获取目标Z轴尺寸和当前Z轴尺寸
                target_z = obj_b.dimensions.z
                current_z = obj_a.dimensions.z

                # 避免除以零错误
                if current_z == 0:
                    print("Error: 物体A的Z轴尺寸为0，无法缩放")
                    return

                if target_z == current_z:
                    print('尺寸相同，无法缩放')
                    return

                # 直接计算缩放因子
                scale_factor = target_z / current_z

                # 应用缩放因子到所有轴向（保持比例）
                obj_a.scale *= scale_factor

                # 更新视图层以确保尺寸计算准确
                bpy.context.view_layer.update()

                # 应用缩放变换
                bpy.ops.object.select_all(action='DESELECT')
                obj_a.select_set(True)
                bpy.context.view_layer.objects.active = obj_a
                bpy.ops.object.transform_apply(location=False, rotation=False, scale=True)

        def Move_location(A,B):
            object_a = A
            object_b = B

            if object_a and object_b:
                object_a_copy = object_a.copy()  # 复制物体 A

                # 获取物体 B 的世界矩阵
                world_matrix_b = object_b.matrix_world

                # 计算物体 A 的世界矩阵
                world_matrix_a = object_a.matrix_world

                # 计算新的局部变换矩阵
                new_world_matrix = world_matrix_b @ world_matrix_a.inverted()

                # 应用新的局部变换矩阵到物体 A
                object_a.matrix_local = new_world_matrix
                object_a.scale = object_a_copy.scale  # 保留原始缩放
                # 删除object_a_copy
                bpy.data.objects.remove(object_a_copy, do_unlink=True)
                # 更新场景
                bpy.context.view_layer.update()

            else:
                print("未找到指定的物体")

        def rotate_bone_x(armature_object, bone_name, angle_deg=10, armature_apply=True):

            bpy.ops.object.mode_set(mode='POSE')

            # 获取姿态骨骼
            pose_bone = armature_object.pose.bones.get(bone_name)

            # 欧拉旋转
            pose_bone.rotation_mode = 'XYZ'

            # 转换为弧度并应用旋转
            angle_rad = radians(angle_deg)
            pose_bone.rotation_euler.x += angle_rad
            if armature_apply:
                bpy.ops.pose.armature_apply(selected=False)

        def match_bone_transforms(arm, hand_ik, hand_fk):

            # 获取对象
            armature_obj = arm

            # 确保对象是骨骼对象
            if armature_obj.type == 'ARMATURE':
                # 进入姿态模式
                bpy.ops.object.mode_set(mode='POSE')

                # 获取骨骼数据
                pose_bones = armature_obj.pose.bones

                # 获取 hand_ik 和 hand_fk 骨骼
                hand_ik_bone = pose_bones.get(hand_ik)
                hand_fk_bone = pose_bones.get(hand_fk)

                if hand_ik_bone and hand_fk_bone:

                    # 获取 hand_fk 骨骼的世界空间矩阵
                    hand_fk_matrix_world = armature_obj.matrix_world @ hand_fk_bone.matrix

                    # 计算 hand_ik 骨骼的本地空间矩阵
                    hand_ik_matrix_local = armature_obj.matrix_world.inverted() @ hand_fk_matrix_world

                    # 将 hand_ik 骨骼的本地空间矩阵设置为计算得到的矩阵
                    hand_ik_bone.matrix = hand_ik_matrix_local

        def calculate_tail_coordinates(bone_name, bone_name2, arm_obj_name, scale = True, distance = False, lengths = False):

            arm = bpy.data.objects.get(arm_obj_name)

            bpy.context.view_layer.objects.active = arm
            bpy.ops.object.mode_set(mode='EDIT')  # 切到编辑模式

            # 确保骨骼存在
            if bone_name not in arm.data.edit_bones or bone_name2 not in arm.data.edit_bones:
                print(f"骨骼 {bone_name} 或 {bone_name2} 不存在于骨架 {arm_obj_name} 中")
                return

            bone1 = arm.data.edit_bones.get(bone_name)
            bone2 = arm.data.edit_bones.get(bone_name2)

            bone1_head = bone1.head # 头坐标
            bone1_tail = bone1.tail # 尾坐标
            bone2_length = bone2.length # 长度
            bone1_length = bone1.length # 长度

            if distance:
                head1 = np.array([bone1_head.x, bone1_head.y, bone1_head.z])
                tail1 = np.array([bone1_tail.x, bone1_tail.y, bone1_tail.z])

                # 计算方向向量和缩放因子
                direction = tail1 - head1
                length = np.linalg.norm(direction)
                if lengths:
                    k = bone1_length / length  # 缩放因子
                else:
                    k = bone2_length / length  # 缩放因子


                # 生成两种方向的尾坐标
                scaled_dir1 = direction * k  # 原方向
                scaled_dir2 = -direction * k  # 反方向
                tail2_case1 = tail1 + scaled_dir1
                tail2_case2 = tail1 + scaled_dir2

                # 计算到 head1 的距离
                distance_case1 = np.linalg.norm(head1 - tail2_case1)
                distance_case2 = np.linalg.norm(head1 - tail2_case2)

                if distance_case1 > distance_case2:  # 选择距离更长的
                    bone2.tail = tail2_case1
                    print(f"Case 1 尾坐标: {np.round(tail2_case1, 4)}, 距离: {np.round(distance_case1, 4)}")
                else:
                    bone2.tail = tail2_case2
                    print(f"Case 2 尾坐标: {np.round(tail2_case2, 4)}, 距离: {np.round(distance_case2, 4)}")

            if not distance:
                bone2.tail = bone1_head
                if scale:
                    bone2.length = bone2_length

        def Calculate_intersection_angle(Arm, a_bone, b_bone):

            bpy.ops.object.mode_set(mode='EDIT')

            A_bone = Arm.data.edit_bones.get(a_bone)
            B_bone = Arm.data.edit_bones.get(b_bone)

            # 定义点坐标
            A = np.array([A_bone.head.x, A_bone.head.y, A_bone.head.z])  # 起点
            B = np.array([B_bone.head.x, B_bone.head.y, B_bone.head.z])  # 交点
            C = np.array([B_bone.tail.x, B_bone.tail.y, B_bone.tail.z])  # 终点

            # 计算从交点B出发的向量
            BA = A - B  # 向量BA
            BC = C - B  # 向量BC

            # 计算点积
            dot_product = np.dot(BA, BC)

            # 计算向量模长
            norm_BA = np.linalg.norm(BA)
            norm_BC = np.linalg.norm(BC)

            # 计算夹角余弦值
            cos_theta = dot_product / (norm_BA * norm_BC)

            # 计算夹角（弧度）
            theta_rad = np.arccos(np.clip(cos_theta, -1.0, 1.0))

            # 转换为角度
            theta_deg = np.degrees(theta_rad)

            # 输出结果
            print('骨骼: ', a_bone, b_bone)
            print(f"向量 BA: {BA}")
            print(f"向量 BC: {BC}")
            print(f"点积: {dot_product}")
            print(f"向量 BA 模长: {norm_BA:.6f}")
            print(f"向量 BC 模长: {norm_BC:.6f}")
            print(f"余弦值: {cos_theta:.6f}")
            print(f"角度(弧度): {theta_rad:.6f}")
            print(f"角度(度数): {theta_deg:.6f}")
            print('------------------')

            return theta_deg

        # 获取某个骨骼的世界空间z轴坐标
        def get_bone_world_z(bone_name, armature_obj):
            # 切换到姿势模式
            bpy.context.view_layer.objects.active = armature_obj
            bpy.ops.object.mode_set(mode='POSE')

            # 获取骨骼
            pose_bone = armature_obj.pose.bones.get(bone_name)
            if not pose_bone:
                print(f"骨骼 {bone_name} 不存在")
                return

            # 获取骨骼z轴坐标
            z_coordinate = pose_bone.matrix.translation.z
            return z_coordinate

        # 设置骨骼的世界空间z轴坐标(在姿势模式)
        def set_bone_world_z(bone_name, armature_obj, z_value):
            # 切换到姿势模式
            bpy.context.view_layer.objects.active = armature_obj
            bpy.ops.object.mode_set(mode='POSE')

            # 获取骨骼
            pose_bone = armature_obj.pose.bones.get(bone_name)
            if not pose_bone:
                print(f"骨骼 {bone_name} 不存在")
                return

            # 设置骨骼z轴坐标
            pose_bone.matrix.translation.z = z_value

            # 应用变换
            bpy.ops.pose.armature_apply(selected=False)

        # 版本比较
        def compare_version(version1, version2):
            parts1 = []
            parts2 = []
            for part in re.split('[.-]', version1):
                try:
                    num = int(part)
                except ValueError:
                    num = 0
                parts1.append(num)
            for part in re.split('[.-]', version2):
                try:
                    num = int(part)
                except ValueError:
                    num = 0
                parts2.append(num)
            min_length = min(len(parts1), len(parts2))
            for i in range(min_length):
                if parts1[i] < parts2[i]:
                    return True
                elif parts1[i] > parts2[i]:
                    return False
            return len(parts1) < len(parts2)

        finger_bone = []

        arm_number = 0

        config = {
            "Arm_L": "upper_arm.L",
            "Arm_R": "upper_arm.R",
            "Elbow_L": "forearm.L",
            "Elbow_R": "forearm.R",
            "Shoulder_L": "shoulder.L",
            "Shoulder_R": "shoulder.R",
            "Thigh_L": "thigh.L",
            "Thigh_R": "thigh.R",
            "Knee_L": "shin.L",
            "Knee_R": "shin.R",
            "Ankle_offset_L": "foot.L",
            "Ankle_offset_R": "foot.R",
            "Toe_L": "toe.L",
            "Toe_R": "toe.R",
            "Wrist_L": "hand.L",
            "Wrist_R": "hand.R",
            "Hip": "spine",
            "Waist": "spine.001",
            "Spine": "spine.002",
            "Chest": "spine.003",
            "Neck": "spine.004",
            "Head": "spine.006",
            "Eye_L": "eye.L",
            "Eye_R": "eye.R",
            "Thumb_01_R": "thumb.01.R",
            "Thumb_02_R": "thumb.02.R",
            "Thumb_03_R": "thumb.03.R",
            "Index_01_R": "f_index.01.R",
            "Index_02_R": "f_index.02.R",
            "Index_03_R": "f_index.03.R",
            "Middle_01_R": "f_middle.01.R",
            "Middle_02_R": "f_middle.02.R",
            "Middle_03_R": "f_middle.03.R",
            "Ring_01_R": "f_ring.01.R",
            "Ring_02_R": "f_ring.02.R",
            "Ring_03_R": "f_ring.03.R",
            "Pinky_01_R": "f_pinky.01.R",
            "Pinky_02_R": "f_pinky.02.R",
            "Pinky_03_R": "f_pinky.03.R",
            "Thumb_01_L": "thumb.01.L",
            "Thumb_02_L": "thumb.02.L",
            "Thumb_03_L": "thumb.03.L",
            "Index_01_L": "f_index.01.L",
            "Index_02_L": "f_index.02.L",
            "Index_03_L": "f_index.03.L",
            "Middle_01_L": "f_middle.01.L",
            "Middle_02_L": "f_middle.02.L",
            "Middle_03_L": "f_middle.03.L",
            "Ring_01_L": "f_ring.01.L",
            "Ring_02_L": "f_ring.02.L",
            "Ring_03_L": "f_ring.03.L",
            "Pinky_01_L": "f_pinky.01.L",
            "Pinky_02_L": "f_pinky.02.L",
            "Pinky_03_L": "f_pinky.03.L"
        }

        if not RIG.mmr.Generate_controllers:

            # 变换
            Move_location(mmd_arm,RIG)
            # 缩放
            Size_settings(RIG,mmd_arm)

            # 遍历字典的键值对并打印
            for key, value in config.items():
                print(f"键名: {key}, 值: {value}")

                if check_keywords(value, ["thumb", "index", "middle", "ring", "pinky"]):
                    finger_bone.append(value)

                # 调用函数
                align_bones(value, RIG, key, mmd_arm)

                if value == "spine.006":
                    # 移动到正确位置
                    move_bone_a_to_b(RIG.name, mmd_arm.name, "face", key)
                    # 遍历字典的键值
                    for key, value in config.items():
                        # 眼睛
                        if value == "eye.L" or value == "eye.R":
                            move_bone_a_to_b(RIG.name, mmd_arm.name, value, key)

                if align_bones(value, RIG, key, mmd_arm, count=True):
                    arm_number += 1
                    # 激活物体      
                    bpy.context.view_layer.objects.active = RIG
                    # 选择物体
                    RIG.select_set(True)
                    # 应用
                    bpy.ops.object.mode_set(mode='POSE')
                    bpy.ops.pose.armature_apply(selected=False)

            # 手掌修正
            if not mmd_arm.mmr.Disable_hand_fix:
                for key, value in config.items():
                    if 'hand' in value:
                        if determine_side(value):
                            calculate_tail_coordinates('forearm.L', 'hand.L', RIG.name,distance=True)
                        else:
                            calculate_tail_coordinates('forearm.R', 'hand.R', RIG.name,distance=True)

                if value == 'spine.003':
                    calculate_tail_coordinates('spine.004', 'spine.003', RIG.name, scale=False)

                if 'foot' in value:
                    if determine_side(value):
                        move_bone_a_to_b(RIG.name, RIG.name, "heel.02.L", value, A_bone_Z_location=True)
                    else:
                        move_bone_a_to_b(RIG.name, RIG.name, "heel.02.R", value, A_bone_Z_location=True)

            palm_aligs = {
                'palm.01.L': 'f_index.01.L',
                'palm.01.R': 'f_index.01.R',
                'palm.02.L': 'f_middle.01.L',
                'palm.02.R': 'f_middle.01.R',
                'palm.03.L': 'f_ring.01.L',
                'palm.03.R': 'f_ring.01.R',
                'palm.04.L': 'f_pinky.01.L',
                'palm.04.R': 'f_pinky.01.R',
            }

            for key, value in palm_aligs.items():
                align_bones(key, RIG, value, RIG, length=2)
                finger_bone.append(key)

                bpy.ops.object.mode_set(mode='POSE')  # 切到pose模式
                bpy.ops.pose.armature_apply(selected=False)  # 应用

            finger_bone_L = []
            finger_bone_R = []

            for v in finger_bone:
                if determine_side(v):
                    finger_bone_L.append(v)
                else:
                    finger_bone_R.append(v)

            bpy.context.view_layer.objects.active = RIG
            bpy.ops.object.mode_set(mode='EDIT')  # 切到编辑模式

            if mmr.f_pin:
                for key, value in config.items():
                    if '03' in value:
                        f_pin = ['thumb', 'index', 'middle', 'ring', 'pinky']
                        for f in f_pin:
                            if f in value:
                                v_bone = RIG.data.edit_bones.get(value)
                                if format(v_bone.head.x, '.4f') == format(v_bone.tail.x, '.4f'):
                                    if format(v_bone.head.y, '.4f') == format(v_bone.tail.y, '.4f'):
                                        pinky_parent = v_bone.parent.name
                                        calculate_tail_coordinates(pinky_parent, value, RIG.name, distance=True,lengths=True)

            for bone in RIG.data.edit_bones:  # 遍历所有骨骼
                bone.select = bone.name in finger_bone_R  # True=选中，False=不选
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')  # 原本想设x的,看到0.56 MMR这样用的,就这样吧
            bpy.ops.armature.select_all(action='DESELECT')  # 取消所有选择

            for bone in RIG.data.edit_bones:
                bone.select = bone.name in finger_bone_L
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
            bpy.ops.armature.select_all(action='DESELECT')

            roll_thumb = 'GLOBAL_NEG_Y'

            if mmr.Thumb_twist_aligns_with_the_world_Z_axis:
                roll_thumb = 'GLOBAL_POS_Z'

            for bone in RIG.data.edit_bones:
                if bone.name in finger_bone_R:
                    if 'thumb' in bone.name:
                        bone.select = True
                        bpy.ops.armature.calculate_roll(type=roll_thumb)
                        bpy.ops.armature.select_all(action='DESELECT')
                else:
                    if bone.name in finger_bone_L:
                        if 'thumb' in bone.name:
                            bone.select = True
                            bpy.ops.armature.calculate_roll(type=roll_thumb)
                            bpy.ops.armature.select_all(action='DESELECT')

            bjiy_1 = ['thigh.L', 'shin.L',
                      'thigh.R', 'shin.R']

            bjiy_2 = ['spine', 'spine.001',
                      'spine.002', 'spine.003',
                      'spine.004', 'spine.006',
                      'upper_arm.L', 'forearm.L',
                      'hand.L', 'upper_arm.R',
                      'forearm.R', 'hand.R']

            bjiy_3 = ['thigh.L', 'shin.L', 'foot.L', 'toe.L', 'thigh.R', 'shin.R', 'foot.R', 'toe.R']

            bjiy_4 = {'foot.L': 'toe.L', 'foot.R': 'toe.R'}

            bjiy_5 = ['shoulder.L', 'shoulder.R']

            for bone in RIG.data.edit_bones:
                bone.select = bone.name in bjiy_2
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Y')
            bpy.ops.armature.select_all(action='DESELECT')

            for bone in RIG.data.edit_bones:
                bone.select = bone.name in bjiy_2
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Y')
            bpy.ops.armature.select_all(action='DESELECT')

            for bone in RIG.data.edit_bones:
                bone.select = bone.name in bjiy_3
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Y')
            bpy.ops.armature.select_all(action='DESELECT')

            for k, v in bjiy_4.items():
                for bone in RIG.data.edit_bones:
                    if bone.name == k:
                        bone.select = True
                        bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
                        bpy.ops.armature.select_all(action='DESELECT')
                    if bone.name == v:
                        bone.select = True
                        bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
                        bpy.ops.armature.select_all(action='DESELECT')

            for bone in RIG.data.edit_bones:
                bone.select = bone.name in bjiy_5
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
            bpy.ops.armature.select_all(action='DESELECT')
        else:
            mmd_arm = context.object.mmr.mmd_Armature

        if mmr.Only_meta_bones_are_generated:
            mmr.Only_meta_bones_are_generated = False
            RIG.mmr.presets = mmd_arm.mmr.presets
            RIG.mmr.Import_presets = mmd_arm.mmr.Import_presets
            RIG.mmr.json_filepath = mmd_arm.mmr.json_filepath
            RIG.mmr.Generate_controllers = True
            RIG.mmr.mmd_Armature = mmd_arm
            mmd_arm.matrix_world = mmd_arm_matrix  # 还原位置
            RIG.matrix_world = mmd_arm_matrix  # 吸附位置
            RIG.show_in_front = True # 在前面
            RIG.mmr.MMR_Arm = True
            return {'FINISHED'}

        # 更新场景
        bpy.context.view_layer.update()

        bpy.ops.object.mode_set(mode='POSE')  # 切到姿态模式

        ct_op = {}

        # 备份所有骨骼的Set_constraints
        for bone in RIG.data.bones:
            lists = []
            for item in bone.mmr_bone.Set_constraints:
                lists.append(item)

            ct_op[bone.name] = lists

        bpy.ops.object.mode_set(mode='EDIT')  # 切到编辑模式

        BackupMatrix = {}

        # 备份所有骨骼的矩阵
        for bone in RIG.data.edit_bones:
            bone_matrix = bone.matrix.copy()
            # 世界矩阵
            bone_world_matrix = bone_matrix @ RIG.matrix_world
            # 备份世界矩阵
            BackupMatrix[bone.name] = bone_world_matrix

        # 激活骨架
        bpy.context.view_layer.objects.active = RIG
        RIG.select_set(True)

        foot_L_world_z = get_bone_world_z('foot.L',RIG)
        foot_R_world_z = get_bone_world_z('foot.R',RIG)

        heel_bones = ['heel.02.L', 'heel.02.R']

        heel_L_world_z = get_bone_world_z('heel.02.L',RIG)
        heel_R_world_z = get_bone_world_z('heel.02.R',RIG)

        heel_world_z = (heel_L_world_z + heel_R_world_z) / 2

        # 角度
        v = mmr.Bend_angle_leg
        v1 = mmr.Bend_angle_arm

        # 弯曲骨骼
        if mmr.Bend_the_bones:
            if Calculate_intersection_angle(RIG, 'upper_arm.L', 'forearm.L') > 165:
                rotate_bone_x(RIG,'upper_arm.L',angle_deg=-v1)
                rotate_bone_x(RIG,'forearm.L',angle_deg=v1*2)

            if Calculate_intersection_angle(RIG, 'upper_arm.R', 'forearm.R') > 165:
                rotate_bone_x(RIG,'upper_arm.R',angle_deg=-v1)
                rotate_bone_x(RIG,'forearm.R',angle_deg=v1*2)

        # 弯曲腿部骨骼
        if mmr.Bend_the_leg_bones:

            print('heel_world_z: ', heel_world_z)

            if Calculate_intersection_angle(RIG, 'thigh.L', 'shin.L') > 165:
                rotate_bone_x(RIG, 'thigh.L',angle_deg=-v)
                rotate_bone_x(RIG, 'shin.L',angle_deg=v*2)
                rotate_bone_x(RIG, 'foot.L',angle_deg=-v)

            if Calculate_intersection_angle(RIG, 'thigh.R', 'shin.R') > 165:
                rotate_bone_x(RIG, 'thigh.R',angle_deg=-v)
                rotate_bone_x(RIG, 'shin.R',angle_deg=v*2)
                rotate_bone_x(RIG, 'foot.R',angle_deg=-v)

            foot_L_world_z_1 = get_bone_world_z('foot.L', RIG)
            foot_R_world_z_1 = get_bone_world_z('foot.R', RIG)

            foot_L_world_z_difference = foot_L_world_z_1 - foot_L_world_z
            foot_R_world_z_difference = foot_R_world_z_1 - foot_R_world_z

            foot_world_z_difference = (foot_L_world_z_difference + foot_R_world_z_difference) / 2

            print('foot_world_z 差异: ', foot_world_z_difference)

            spine_world_z = get_bone_world_z('spine',RIG)
            print('spine_world_z: ', spine_world_z)

            spine_world_z_1 = spine_world_z - foot_world_z_difference
            print('spine_world_z 坐标: ', spine_world_z_1)

            set_bone_world_z('spine',RIG,spine_world_z_1)

            for bone in heel_bones:
                set_bone_world_z(bone,RIG,heel_world_z)

        u = "WGTS_" + RIG.name
        if u in bpy.data.collections:
            bpy.context.object.data.rigify_widgets_collection = bpy.data.collections["WGTS_" + RIG.name]

        RIG.name = 'MMR-' + mmd_arm.name

        # 生成
        bpy.ops.pose.rigify_generate()

        rigify = bpy.context.active_object
        rigify.name = 'RIG-' + mmd_arm.name

        # 设置父子级
        for key, value in config.items():

            # 原始矩阵
            org_matrix = BackupMatrix.get(value)

            if org_matrix is None:
                print(f"骨骼 {value} 不存在于org_matrix中")
                continue

            value = 'ORG-' + value

            # 进入RIG的编辑模式
            bpy.context.view_layer.objects.active = rigify
            bpy.ops.object.mode_set(mode='EDIT')
            # 进入mmd_arm的编辑模式
            bpy.context.view_layer.objects.active = mmd_arm
            bpy.ops.object.mode_set(mode='EDIT')

            mmd_edit_bones = mmd_arm.data.edit_bones
            rigify_edit_bones = rigify.data.edit_bones

            if 'eye' in value:
                continue

            # 检查骨骼是否存在
            if key in mmd_edit_bones and value in rigify_edit_bones:
                # 获取骨骼对象
                mmd_bone = mmd_edit_bones[key]
                rigify_bone = rigify_edit_bones[value]
                # 新建骨骼
                new_bone = rigify_edit_bones.new(name=value + '_parent')
                new_bone.head = mmd_bone.head  # 复制头位置
                new_bone.tail = mmd_bone.tail  # 复制尾位置
                new_bone.roll = mmd_bone.roll  # 复制旋转
                new_bone.parent = rigify_bone  # 设置父级

                # 获取骨骼矩阵
                new_bone_matrix = new_bone.matrix
                # 世界空间矩阵
                new_bone_world_matrix = new_bone_matrix @ rigify.matrix_world
                # 获取rigify骨骼矩阵
                rigify_bone_matrix = rigify_bone.matrix
                # 获取rigify骨骼世界空间矩阵
                rigify_bone_world_matrix = rigify_bone_matrix @ rigify.matrix_world

                # 计算相对变换矩阵
                relative_matrix = org_matrix.inverted() @ new_bone_world_matrix
                # 得到新的世界空间矩阵
                new_bone_world_matrix = rigify_bone_world_matrix @ relative_matrix

                # 转换为局部空间
                new_bone_matrix = new_bone_world_matrix @ rigify.matrix_world.inverted()
                new_bone.matrix = new_bone_matrix

                bpy.ops.object.mode_set(mode='POSE')

                # 加入集合
                bone = rigify.pose.bones.get(value + '_parent')
                rigify.data.collections_all['ORG'].assign(bone)
            else:
                print(f"骨骼 {key} 或 {value} 不存在于骨架中")

        # 设置捩骨
        Twist_bones = [
            {
                'forearm.L': 'ArmRoll_L', 
                'forearm.R': 'ArmRoll_R', 
                'upper_arm.L': 'ShoulderRoll_L', 
                'upper_arm.R': 'ShoulderRoll_R'
            },
            {
                'DEF-forearm.L.001': 'ArmRoll_L', 
                'DEF-forearm.R.001': 'ArmRoll_R', 
                'DEF-upper_arm.L.001': 'ShoulderRoll_L', 
                'DEF-upper_arm.R.001': 'ShoulderRoll_R'
            }
        ]

        for key, value in Twist_bones[0].items():

            # 原始矩阵
            org_matrix = BackupMatrix.get(key)

            if org_matrix is None:
                print(f"骨骼 {key} 不存在于org_matrix中")
                continue

            key = 'DEF-' + key

            # 进入RIG的编辑模式
            bpy.context.view_layer.objects.active = rigify
            bpy.ops.object.mode_set(mode='EDIT')
            # 进入mmd_arm的编辑模式
            bpy.context.view_layer.objects.active = mmd_arm
            bpy.ops.object.mode_set(mode='EDIT')

            mmd_edit_bones = mmd_arm.data.edit_bones
            rigify_edit_bones = rigify.data.edit_bones

            # 获取骨骼
            mmd_bone = mmd_edit_bones.get(value)
            rigify_bone = rigify_edit_bones.get(key)

            if not mmd_bone or not rigify_bone:
                print(f"骨骼 {value} 或 {key} 不存在于骨架中")
                continue

            value = 'ORG-' + value

            # 新建骨骼
            new_bone = rigify_edit_bones.new(name=value + '_parent')
            new_bone.head = mmd_bone.head  # 复制头位置
            new_bone.tail = mmd_bone.tail  # 复制尾位置
            new_bone.roll = mmd_bone.roll  # 复制旋转
            new_bone.parent = rigify_bone

            # 获取骨骼矩阵
            new_bone_matrix = new_bone.matrix
            # 世界空间矩阵
            new_bone_world_matrix = new_bone_matrix @ rigify.matrix_world
            # 获取rigify骨骼矩阵
            rigify_bone_matrix = rigify_bone.matrix
            # 获取rigify骨骼世界空间矩阵
            rigify_bone_world_matrix = rigify_bone_matrix @ rigify.matrix_world

            # 计算相对变换矩阵
            relative_matrix = org_matrix.inverted() @ new_bone_world_matrix
            # 得到新的世界空间矩阵
            new_bone_world_matrix = rigify_bone_world_matrix @ relative_matrix

            # 转换为局部空间
            new_bone_matrix = new_bone_world_matrix @ rigify.matrix_world.inverted()
            new_bone.matrix = new_bone_matrix

            bpy.ops.object.mode_set(mode='POSE')

            # 加入集合
            bone = rigify.pose.bones.get(value + '_parent')
            rigify.data.collections_all['ORG'].assign(bone)

        bpy.ops.object.mode_set(mode='EDIT')

        if not mmr.ORG_mode:
            for key, value in config.items():
                if 'eye' in value:
                    continue

                value1 = 'ORG-' + value + '_parent'

                # 进入编辑模式
                bpy.context.view_layer.objects.active = rigify
                bpy.ops.object.mode_set(mode='EDIT')

                bone = rigify.data.edit_bones.get(value1)

                if value1 in rigify.data.edit_bones:
                    # 父级
                    bone.parent = rigify.data.edit_bones['DEF-' + value]

        eye_pt = ['eye.L', 'eye.R']

        for n in eye_pt:
            for k , v in config.items():
                if v == n:
                    n = 'ORG-' + v
                    # 进入编辑模式
                    bpy.context.view_layer.objects.active = rigify
                    bpy.ops.object.mode_set(mode='EDIT')
                    bpy.context.view_layer.objects.active = mmd_arm
                    bpy.ops.object.mode_set(mode='EDIT')

                    edit_bones = rigify.data.edit_bones
                    mmd_edit_bones = mmd_arm.data.edit_bones

                    s_bone = edit_bones[n]
                    m_bone = mmd_edit_bones[k]

                    # 复制骨骼（新建骨骼并复制属性）
                    new_bone = edit_bones.new(name = n +'_parent')
                    # 位置
                    new_bone.head = m_bone.head
                    new_bone.tail = m_bone.tail
                    # 扭转
                    new_bone.roll = m_bone.roll

        bpy.context.view_layer.objects.active = rigify
        rigify.select_set(True)
        bpy.ops.object.mode_set(mode='POSE')
        # 应用姿态
        bpy.ops.pose.armature_apply(selected=False)

        for k in eye_pt:
            # 进入编辑模式
            bpy.ops.object.mode_set(mode='EDIT')

            edit_bones = rigify.data.edit_bones

            s_bone = edit_bones['ORG-' + k + '_parent']
            e_bone = edit_bones['ORG-' + k]

            # 父级
            s_bone.parent = e_bone

            bpy.ops.object.mode_set(mode='POSE')
            # 加入集合
            data_bones = rigify.data.bones
            t_bone = data_bones.get('ORG-' + k + '_parent')
            rigify.data.collections_all['ORG'].assign(t_bone)

        # 捩骨约束
        for key, value in Twist_bones[1].items():
            value1 = 'ORG-' + value + '_parent'
            # 进入编辑模式
            bpy.ops.object.mode_set(mode='EDIT')
            edit_bones = rigify.data.edit_bones

            bone1 = edit_bones.get(key)
            bone2 = edit_bones.get(value1)

            if key in edit_bones and value1 in edit_bones:
                bone2.parent = bone1

            bpy.context.view_layer.objects.active = mmd_arm
            mmd_arm.select_set(True)
            bpy.ops.object.mode_set(mode='POSE')

            bone = mmd_arm.pose.bones.get(value)  # 获取骨骼

            # 检查骨骼是否存在
            if bone is None:
                print(f"警告: 未找到名为 {value} 的骨骼，跳过约束操作")
                continue  # 跳过后续约束

            # 删除所有约束
            for constraint in list(bone.constraints):
                if constraint.name == 'MMR_复制旋转':
                    bone.constraints.remove(constraint)

            # 添加复制旋转约束
            constraint = bone.constraints.new(type='COPY_ROTATION')  # 复制旋转
            constraint.name = 'MMR_复制旋转'
            constraint.target = rigify
            constraint.subtarget = value1

        constraint_names = ['MMR_复制旋转', 'MMR_复制位置', 'MMR_复制缩放']

        # 添加约束
        for key, value in config.items():

            value1 = 'ORG-' + value + '_parent'

            print(f"键名: {key}, 值: {value1}")

            bpy.context.view_layer.objects.active = mmd_arm
            mmd_arm.select_set(True)
            bpy.ops.object.mode_set(mode='POSE')

            bone = mmd_arm.pose.bones.get(key)  # 获取骨骼

            # 检查骨骼是否存在
            if bone is None:
                print(f"警告: 未找到名为 {key} 的骨骼，跳过约束操作")
                continue  # 跳过后续约束

            # 删除所有约束
            for constraint in list(bone.constraints):
                if constraint.name in constraint_names:
                    bone.constraints.remove(constraint)

            # 添加复制旋转约束
            constraint = bone.constraints.new(type='COPY_ROTATION')  # 复制旋转
            constraint.name = constraint_names[0]
            constraint.target = rigify
            constraint.subtarget = value1
            if not (ct_op.get(value))[0]:
                constraint.influence = 0

            # 添加复制位置约束
            constraint = bone.constraints.new(type='COPY_TRANSFORMS')  # 复制位置
            constraint.name = constraint_names[1]
            constraint.target = rigify
            constraint.subtarget = value1
            if not (ct_op.get(value))[1]:
                constraint.influence = 0

            # 添加复制缩放约束
            constraint = bone.constraints.new(type='COPY_SCALE')  # 复制缩放
            constraint.name = constraint_names[2]
            constraint.target = rigify
            constraint.subtarget = value1
            if not (ct_op.get(value))[2]:
                constraint.influence = 0

        subtarget = ['つま先ＩＫ.L', 'つま先ＩＫ.R', '足ＩＫ.R', '足ＩＫ.L']

        mmd_arms = True # 是否是mmd的armature

        # 遍历骨骼
        for bone in mmd_arm.pose.bones:
            # 遍历骨骼约束
            for constraint in bone.constraints:
                # 类型是否为IK
                if constraint.type == 'IK':
                    for s in subtarget:
                        if constraint.subtarget == s:
                            # 设置影响值为0
                            constraint.influence = 0.0
                            print(f"已将骨骼 '{bone.name}' 的IK约束影响值设置为0")
                            mmd_arms = False
        if mmd_arms:
            # 遍历骨骼
            for bone in mmd_arm.pose.bones:
                # 遍历骨骼约束
                for constraint in bone.constraints:
                    # 类型是否为IK
                    if constraint.type == 'IK':
                        # 设置影响值为0
                        constraint.influence = 0.0
                        print(f"已将骨骼 '{bone.name}' 的IK约束影响值设置为0")

        bpy.context.view_layer.objects.active = rigify
        rigify.select_set(True)
        # 进入编辑模式
        bpy.ops.object.mode_set(mode='EDIT')

        edit_bones = rigify.data.edit_bones

        e_bone = edit_bones['thigh_ik.R']
        c_bone = edit_bones['torso']
        root_bone = edit_bones['root']
        L_bone = edit_bones['hand_ik.L']
        R_bone = edit_bones['hand_ik.R']

        # 复制骨骼（新建骨骼并复制属性）
        new_bone = edit_bones.new(name='torso_root')
        # 位置
        new_bone.head.x = c_bone.head.copy().x
        new_bone.head.y = c_bone.head.copy().y
        new_bone.head.z = e_bone.tail.copy().z
        new_bone.tail.x = c_bone.tail.copy().x
        new_bone.tail.y = c_bone.tail.copy().y
        new_bone.tail.z = e_bone.tail.copy().z
        # 父级
        new_bone.parent = root_bone
        c_bone.parent = new_bone
        R_bone.parent = new_bone
        L_bone.parent = new_bone
        # 形状
        bpy.ops.object.mode_set(mode='POSE')
        pose_bones = rigify.pose.bones
        t_bone = pose_bones.get('torso_root')
        t_bone.color.palette = 'THEME09'
        t_bone.custom_shape = bpy.data.objects["WGT-RIG-" + RIG.name + "_root"]
        # 加入集合
        data_bones = rigify.data.bones
        t_bone = data_bones.get('torso_root')
        rigify.data.collections_all['Torso'].assign(t_bone)

        rigify.show_in_front = True # 在前面

        if mmr.Upper_body_linkage:
            rigify.pose.bones["torso"]["neck_follow"] = 0
            rigify.pose.bones["torso"]["head_follow"] = 0
        else:
            rigify.pose.bones["torso"]["neck_follow"] = 1
            rigify.pose.bones["torso"]["head_follow"] = 1

        is_gto = ['Face (Primary)', 'Face (Secondary)', 'Torso (Tweak)', 'Fingers (Detail)', 'Arm.L (FK)', 'Arm.R (FK)',
                  'Arm.L (Tweak)', 'Arm.R (Tweak)', 'Leg.L (FK)', 'Leg.R (FK)', 'Leg.L (Tweak)', 'Leg.R (Tweak)']

        # 隐藏骨骼集合
        for n in is_gto:
            rigify.data.collections_all[n].is_visible = False

        not_bone = ['ear.L', 'ear.R', 'jaw_master', 'teeth.B', 'tongue_master', 'teeth.T', 'nose_master']

        blender_version = bpy.app.version_string

        if compare_version(blender_version, "4.9.9"):
            # 隐藏骨骼
            for n in not_bone:
                bone = rigify.data.bones.get(n)
                bone.hide = True
        else:
            # 隐藏骨骼
            for n in not_bone:
                bone = rigify.pose.bones.get(n)
                bone.hide = True

        ik_stretch = ["upper_arm_parent.L", "upper_arm_parent.R", "thigh_parent.R","thigh_parent.L" ]

        # 关闭ik拉伸
        for i in ik_stretch:
            rigify.pose.bones[i]["IK_Stretch"] = 0

        # 极向目标
        if mmr.Polar_target:
            for i in ik_stretch:
                bone = rigify.pose.bones.get(i)
                bone["pole_vector"] = True

        if mmr.Use_ITASC_solver:
            rigify.pose.ik_solver = 'ITASC' # 设置IK解算器

        bpy.context.scene.tool_settings.transform_pivot_point = 'INDIVIDUAL_ORIGINS' # 各自的原点

        bpy.ops.object.mode_set(mode='OBJECT')

        del_obj = [RIG.name]

        # 删除临时对象
        for y in del_obj:
            bpy.ops.object.select_all(action='DESELECT')
            del_object = bpy.data.objects.get(y)
            del_object.select_set(True)
            bpy.context.view_layer.objects.active = del_object
            bpy.ops.object.delete(use_global=False)

        if not mmr.Hide_mmd_skeleton:
            mmd_arm.hide_set(True) # 隐藏mmd骨架
        else:
            mmd_arm.select_set(True) # 选中mmd骨架

        mmd_arm.matrix_world = mmd_arm_matrix # 还原位置

        rigify.matrix_world = mmd_arm_matrix # 吸附位置

        # 激活并选择最终生成的Rigify骨架
        rigify.select_set(True)
        bpy.context.view_layer.objects.active = rigify

        self.report({'INFO'}, f"生成成功, 匹配骨骼数: {arm_number}")

        return {'FINISHED'}
